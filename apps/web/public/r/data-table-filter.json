{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "data-table-filter",
  "type": "registry:block",
  "title": "Data table filter",
  "author": "Kian Bazarjani <kian@bazza.dev>",
  "description": "A powerful data table filter component inspired by Linear.",
  "dependencies": ["@tanstack/react-table@8.21.2", "date-fns"],
  "registryDependencies": [
    "button",
    "calendar",
    "checkbox",
    "command",
    "dropdown-menu",
    "input",
    "label",
    "popover",
    "separator",
    "slider",
    "table",
    "tabs",
    "use-mobile"
  ],
  "files": [
    {
      "path": "registry/data-table-filter/components/data-table-filter.tsx",
      "content": "'use client'\r\n\r\nimport { Button } from '@/components/ui/button'\r\nimport { Calendar } from '@/components/ui/calendar'\r\nimport { Checkbox } from '@/components/ui/checkbox'\r\nimport {\r\n  Command,\r\n  CommandEmpty,\r\n  CommandGroup,\r\n  CommandInput,\r\n  CommandItem,\r\n  CommandList,\r\n} from '@/components/ui/command'\r\nimport { Input } from '@/components/ui/input'\r\nimport {\r\n  Popover,\r\n  PopoverAnchor,\r\n  PopoverContent,\r\n  PopoverTrigger,\r\n} from '@/components/ui/popover'\r\nimport { Separator } from '@/components/ui/separator'\r\nimport { Slider } from '@/components/ui/slider'\r\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'\r\nimport { useIsMobile } from '@/hooks/use-mobile'\r\nimport { cn } from '@/lib/utils'\r\nimport { take, uniq } from '@/registry/data-table-filter/lib/array'\r\nimport {\r\n  type ColumnDataType,\r\n  type FilterModel,\r\n  createNumberRange,\r\n  dateFilterDetails,\r\n  determineNewOperator,\r\n  filterTypeOperatorDetails,\r\n  getColumn,\r\n  getColumnMeta,\r\n  isColumnOptionArray,\r\n  isFilterableColumn,\r\n  multiOptionFilterDetails,\r\n  numberFilterDetails,\r\n  optionFilterDetails,\r\n  textFilterDetails,\r\n} from '@/registry/data-table-filter/lib/filters'\r\nimport type {\r\n  ColumnOption,\r\n  ElementType,\r\n} from '@/registry/data-table-filter/lib/filters'\r\nimport type { Column, ColumnMeta, RowData, Table } from '@tanstack/react-table'\r\nimport { format, isEqual } from 'date-fns'\r\nimport { FilterXIcon } from 'lucide-react'\r\nimport { ArrowRight, Filter } from 'lucide-react'\r\nimport { X } from 'lucide-react'\r\nimport { Ellipsis } from 'lucide-react'\r\nimport {\r\n  cloneElement,\r\n  isValidElement,\r\n  useEffect,\r\n  useMemo,\r\n  useRef,\r\n  useState,\r\n} from 'react'\r\nimport type { DateRange } from 'react-day-picker'\r\n\r\nexport function DataTableFilter<TData, TValue>({\r\n  table,\r\n}: { table: Table<TData> }) {\r\n  const isMobile = useIsMobile()\r\n\r\n  if (isMobile) {\r\n    return (\r\n      <div className=\"flex w-full items-start justify-between gap-2\">\r\n        <div className=\"flex gap-1\">\r\n          <FilterSelector table={table} />\r\n          <FilterActions table={table} />\r\n        </div>\r\n        <ActiveFiltersMobileContainer>\r\n          <ActiveFilters table={table} />\r\n        </ActiveFiltersMobileContainer>\r\n      </div>\r\n    )\r\n  }\r\n\r\n  return (\r\n    <div className=\"flex w-full items-start justify-between gap-2\">\r\n      <div className=\"flex md:flex-wrap gap-2 w-full flex-1\">\r\n        <FilterSelector table={table} />\r\n        <ActiveFilters table={table} />\r\n      </div>\r\n      <FilterActions table={table} />\r\n    </div>\r\n  )\r\n}\r\n\r\nexport function ActiveFiltersMobileContainer({\r\n  children,\r\n}: { children: React.ReactNode }) {\r\n  const scrollContainerRef = useRef<HTMLDivElement>(null)\r\n  const [showLeftBlur, setShowLeftBlur] = useState(false)\r\n  const [showRightBlur, setShowRightBlur] = useState(true)\r\n\r\n  // Check if there's content to scroll and update blur states\r\n  const checkScroll = () => {\r\n    if (scrollContainerRef.current) {\r\n      const { scrollLeft, scrollWidth, clientWidth } =\r\n        scrollContainerRef.current\r\n\r\n      // Show left blur if scrolled to the right\r\n      setShowLeftBlur(scrollLeft > 0)\r\n\r\n      // Show right blur if there's more content to scroll to the right\r\n      // Add a small buffer (1px) to account for rounding errors\r\n      setShowRightBlur(scrollLeft + clientWidth < scrollWidth - 1)\r\n    }\r\n  }\r\n\r\n  // Log blur states for debugging\r\n  // useEffect(() => {\r\n  //   console.log('left:', showLeftBlur, '  right:', showRightBlur)\r\n  // }, [showLeftBlur, showRightBlur])\r\n\r\n  // Set up ResizeObserver to monitor container size\r\n  useEffect(() => {\r\n    if (scrollContainerRef.current) {\r\n      const resizeObserver = new ResizeObserver(() => {\r\n        checkScroll()\r\n      })\r\n      resizeObserver.observe(scrollContainerRef.current)\r\n      return () => {\r\n        resizeObserver.disconnect()\r\n      }\r\n    }\r\n  }, [])\r\n\r\n  // Update blur states when children change\r\n  useEffect(() => {\r\n    checkScroll()\r\n  }, [children])\r\n\r\n  return (\r\n    <div className=\"relative w-full overflow-x-hidden\">\r\n      {/* Left blur effect */}\r\n      {showLeftBlur && (\r\n        <div className=\"absolute left-0 top-0 bottom-0 w-16 z-10 pointer-events-none bg-gradient-to-r from-background to-transparent animate-in fade-in-0\" />\r\n      )}\r\n\r\n      {/* Scrollable container */}\r\n      <div\r\n        ref={scrollContainerRef}\r\n        className=\"flex gap-2 overflow-x-scroll no-scrollbar\"\r\n        onScroll={checkScroll}\r\n      >\r\n        {children}\r\n      </div>\r\n\r\n      {/* Right blur effect */}\r\n      {showRightBlur && (\r\n        <div className=\"absolute right-0 top-0 bottom-0 w-16 z-10 pointer-events-none bg-gradient-to-l from-background to-transparent animate-in fade-in-0 \" />\r\n      )}\r\n    </div>\r\n  )\r\n}\r\n\r\nexport function FilterActions<TData>({ table }: { table: Table<TData> }) {\r\n  const hasFilters = table.getState().columnFilters.length > 0\r\n\r\n  function clearFilters() {\r\n    table.setColumnFilters([])\r\n    table.setGlobalFilter('')\r\n  }\r\n\r\n  return (\r\n    <Button\r\n      className={cn('h-7 !px-2', !hasFilters && 'hidden')}\r\n      variant=\"destructive\"\r\n      onClick={clearFilters}\r\n    >\r\n      <FilterXIcon />\r\n      <span className=\"hidden md:block\">Clear</span>\r\n    </Button>\r\n  )\r\n}\r\n\r\nexport function FilterSelector<TData>({ table }: { table: Table<TData> }) {\r\n  const [open, setOpen] = useState(false)\r\n  const [value, setValue] = useState('')\r\n  const [property, setProperty] = useState<string | undefined>(undefined)\r\n  const inputRef = useRef<HTMLInputElement>(null)\r\n\r\n  const column = property ? getColumn(table, property) : undefined\r\n  const columnMeta = property ? getColumnMeta(table, property) : undefined\r\n\r\n  const properties = table.getAllColumns().filter(isFilterableColumn)\r\n\r\n  const hasFilters = table.getState().columnFilters.length > 0\r\n\r\n  useEffect(() => {\r\n    if (property && inputRef) {\r\n      inputRef.current?.focus()\r\n      setValue('')\r\n    }\r\n  }, [property])\r\n\r\n  useEffect(() => {\r\n    if (!open) setTimeout(() => setValue(''), 150)\r\n  }, [open])\r\n\r\n  const content = useMemo(\r\n    () =>\r\n      property && column && columnMeta ? (\r\n        <FitlerValueController\r\n          id={property}\r\n          column={column}\r\n          columnMeta={columnMeta}\r\n          table={table}\r\n        />\r\n      ) : (\r\n        <Command loop>\r\n          <CommandInput\r\n            value={value}\r\n            onValueChange={setValue}\r\n            ref={inputRef}\r\n            placeholder=\"Search...\"\r\n          />\r\n          <CommandEmpty>No results.</CommandEmpty>\r\n          <CommandList className=\"max-h-fit\">\r\n            <CommandGroup>\r\n              {properties.map((column) => (\r\n                <FilterableColumn\r\n                  key={column.id}\r\n                  column={column}\r\n                  table={table}\r\n                  setProperty={setProperty}\r\n                />\r\n              ))}\r\n            </CommandGroup>\r\n          </CommandList>\r\n        </Command>\r\n      ),\r\n    [property, column, columnMeta, value, table, properties],\r\n  )\r\n\r\n  return (\r\n    <Popover\r\n      open={open}\r\n      onOpenChange={async (value) => {\r\n        setOpen(value)\r\n        if (!value) setTimeout(() => setProperty(undefined), 100)\r\n      }}\r\n    >\r\n      <PopoverTrigger asChild>\r\n        <Button\r\n          variant=\"outline\"\r\n          className={cn('h-7', hasFilters && 'w-fit !px-2')}\r\n        >\r\n          <Filter className=\"size-4\" />\r\n          {!hasFilters && <span>Filter</span>}\r\n        </Button>\r\n      </PopoverTrigger>\r\n      <PopoverContent\r\n        align=\"start\"\r\n        side=\"bottom\"\r\n        className=\"w-fit p-0 origin-(--radix-popover-content-transform-origin)\"\r\n      >\r\n        {content}\r\n      </PopoverContent>\r\n    </Popover>\r\n  )\r\n}\r\n\r\nexport function FilterableColumn<TData>({\r\n  column,\r\n  setProperty,\r\n}: {\r\n  column: Column<TData>\r\n  table: Table<TData>\r\n  setProperty: (value: string) => void\r\n}) {\r\n  const Icon = column.columnDef.meta?.icon!\r\n  return (\r\n    <CommandItem onSelect={() => setProperty(column.id)} className=\"group\">\r\n      <div className=\"flex w-full items-center justify-between\">\r\n        <div className=\"inline-flex items-center gap-1.5\">\r\n          {<Icon strokeWidth={2.25} className=\"size-4\" />}\r\n          <span>{column.columnDef.meta?.displayName}</span>\r\n        </div>\r\n        <ArrowRight className=\"size-4 opacity-0 group-aria-selected:opacity-100\" />\r\n      </div>\r\n    </CommandItem>\r\n  )\r\n}\r\n\r\nexport function DebouncedInput({\r\n  value: initialValue,\r\n  onChange,\r\n  debounce = 500,\r\n  ...props\r\n}: {\r\n  value: string | number\r\n  onChange: (value: string | number) => void\r\n  debounce?: number\r\n} & Omit<React.InputHTMLAttributes<HTMLInputElement>, 'onChange'>) {\r\n  const [value, setValue] = useState(initialValue)\r\n\r\n  useEffect(() => {\r\n    setValue(initialValue)\r\n  }, [initialValue])\r\n\r\n  useEffect(() => {\r\n    const timeout = setTimeout(() => {\r\n      onChange(value)\r\n    }, debounce)\r\n\r\n    return () => clearTimeout(timeout)\r\n  }, [value, onChange, debounce])\r\n\r\n  return (\r\n    <Input\r\n      {...props}\r\n      value={value}\r\n      onChange={(e) => setValue(e.target.value)}\r\n    />\r\n  )\r\n}\r\n\r\nexport function ActiveFilters<TData>({ table }: { table: Table<TData> }) {\r\n  const filters = table.getState().columnFilters\r\n\r\n  return (\r\n    <>\r\n      {filters.map((filter) => {\r\n        const { id } = filter\r\n\r\n        const column = getColumn(table, id)\r\n        const meta = getColumnMeta(table, id)\r\n\r\n        // Skip if no filter value\r\n        if (!filter.value) return null\r\n\r\n        // Narrow the type based on meta.type and cast filter accordingly\r\n        switch (meta.type) {\r\n          case 'text':\r\n            return renderFilter<TData, 'text'>(\r\n              filter as { id: string; value: FilterModel<'text', TData> },\r\n              column,\r\n              meta as ColumnMeta<TData, unknown> & { type: 'text' },\r\n              table,\r\n            )\r\n          case 'number':\r\n            return renderFilter<TData, 'number'>(\r\n              filter as { id: string; value: FilterModel<'number', TData> },\r\n              column,\r\n              meta as ColumnMeta<TData, unknown> & { type: 'number' },\r\n              table,\r\n            )\r\n          case 'date':\r\n            return renderFilter<TData, 'date'>(\r\n              filter as { id: string; value: FilterModel<'date', TData> },\r\n              column,\r\n              meta as ColumnMeta<TData, unknown> & { type: 'date' },\r\n              table,\r\n            )\r\n          case 'option':\r\n            return renderFilter<TData, 'option'>(\r\n              filter as { id: string; value: FilterModel<'option', TData> },\r\n              column,\r\n              meta as ColumnMeta<TData, unknown> & { type: 'option' },\r\n              table,\r\n            )\r\n          case 'multiOption':\r\n            return renderFilter<TData, 'multiOption'>(\r\n              filter as {\r\n                id: string\r\n                value: FilterModel<'multiOption', TData>\r\n              },\r\n              column,\r\n              meta as ColumnMeta<TData, unknown> & {\r\n                type: 'multiOption'\r\n              },\r\n              table,\r\n            )\r\n          default:\r\n            return null // Handle unknown types gracefully\r\n        }\r\n      })}\r\n    </>\r\n  )\r\n}\r\n\r\n// Generic render function for a filter with type-safe value\r\nfunction renderFilter<TData, T extends ColumnDataType>(\r\n  filter: { id: string; value: FilterModel<T, TData> },\r\n  column: Column<TData, unknown>,\r\n  meta: ColumnMeta<TData, unknown> & { type: T },\r\n  table: Table<TData>,\r\n) {\r\n  const { value } = filter\r\n\r\n  return (\r\n    <div\r\n      key={`filter-${filter.id}`}\r\n      className=\"flex h-7 items-center rounded-2xl border border-border bg-background shadow-xs text-xs\"\r\n    >\r\n      <FilterSubject meta={meta} />\r\n      <Separator orientation=\"vertical\" />\r\n      <FilterOperator\r\n        column={column}\r\n        columnMeta={meta}\r\n        filter={value} // Typed as FilterValue<T>\r\n      />\r\n      <Separator orientation=\"vertical\" />\r\n      <FilterValue\r\n        id={filter.id}\r\n        column={column}\r\n        columnMeta={meta}\r\n        table={table}\r\n      />\r\n      <Separator orientation=\"vertical\" />\r\n      <Button\r\n        variant=\"ghost\"\r\n        className=\"rounded-none rounded-r-2xl text-xs w-7 h-full\"\r\n        onClick={() => table.getColumn(filter.id)?.setFilterValue(undefined)}\r\n      >\r\n        <X className=\"size-4 -translate-x-0.5\" />\r\n      </Button>\r\n    </div>\r\n  )\r\n}\r\n\r\n/****** Property Filter Subject ******/\r\n\r\nexport function FilterSubject<TData>({\r\n  meta,\r\n}: {\r\n  meta: ColumnMeta<TData, string>\r\n}) {\r\n  const hasIcon = !!meta?.icon\r\n  return (\r\n    <span className=\"flex select-none items-center gap-1 whitespace-nowrap px-2 font-medium\">\r\n      {hasIcon && <meta.icon className=\"size-4 stroke-[2.25px]\" />}\r\n      <span>{meta.displayName}</span>\r\n    </span>\r\n  )\r\n}\r\n\r\n/****** Property Filter Operator ******/\r\n\r\n// Renders the filter operator display and menu for a given column filter\r\n// The filter operator display is the label and icon for the filter operator\r\n// The filter operator menu is the dropdown menu for the filter operator\r\nexport function FilterOperator<TData, T extends ColumnDataType>({\r\n  column,\r\n  columnMeta,\r\n  filter,\r\n}: {\r\n  column: Column<TData, unknown>\r\n  columnMeta: ColumnMeta<TData, unknown>\r\n  filter: FilterModel<T, TData>\r\n}) {\r\n  const [open, setOpen] = useState<boolean>(false)\r\n\r\n  const close = () => setOpen(false)\r\n\r\n  return (\r\n    <Popover open={open} onOpenChange={setOpen}>\r\n      <PopoverTrigger asChild>\r\n        <Button\r\n          variant=\"ghost\"\r\n          className=\"m-0 h-full w-fit whitespace-nowrap rounded-none p-0 px-2 text-xs\"\r\n        >\r\n          <FilterOperatorDisplay filter={filter} filterType={columnMeta.type} />\r\n        </Button>\r\n      </PopoverTrigger>\r\n      <PopoverContent\r\n        align=\"start\"\r\n        className=\"w-fit p-0 origin-(--radix-popover-content-transform-origin)\"\r\n      >\r\n        <Command loop>\r\n          <CommandInput placeholder=\"Search...\" />\r\n          <CommandEmpty>No results.</CommandEmpty>\r\n          <CommandList className=\"max-h-fit\">\r\n            <FilterOperatorController column={column} closeController={close} />\r\n          </CommandList>\r\n        </Command>\r\n      </PopoverContent>\r\n    </Popover>\r\n  )\r\n}\r\n\r\nexport function FilterOperatorDisplay<TData, T extends ColumnDataType>({\r\n  filter,\r\n  filterType,\r\n}: {\r\n  filter: FilterModel<T, TData>\r\n  filterType: T\r\n}) {\r\n  const details = filterTypeOperatorDetails[filterType][filter.operator]\r\n\r\n  return <span>{details.label}</span>\r\n}\r\n\r\ninterface FilterOperatorControllerProps<TData> {\r\n  column: Column<TData, unknown>\r\n  closeController: () => void\r\n}\r\n\r\nexport function FilterOperatorController<TData>({\r\n  column,\r\n  closeController,\r\n}: FilterOperatorControllerProps<TData>) {\r\n  const { type } = column.columnDef.meta!\r\n\r\n  switch (type) {\r\n    case 'option':\r\n      return (\r\n        <FilterOperatorOptionController\r\n          column={column}\r\n          closeController={closeController}\r\n        />\r\n      )\r\n    case 'multiOption':\r\n      return (\r\n        <FilterOperatorMultiOptionController\r\n          column={column}\r\n          closeController={closeController}\r\n        />\r\n      )\r\n    case 'date':\r\n      return (\r\n        <FilterOperatorDateController\r\n          column={column}\r\n          closeController={closeController}\r\n        />\r\n      )\r\n    case 'text':\r\n      return (\r\n        <FilterOperatorTextController\r\n          column={column}\r\n          closeController={closeController}\r\n        />\r\n      )\r\n    case 'number':\r\n      return (\r\n        <FilterOperatorNumberController\r\n          column={column}\r\n          closeController={closeController}\r\n        />\r\n      )\r\n    default:\r\n      return null\r\n  }\r\n}\r\n\r\nfunction FilterOperatorOptionController<TData>({\r\n  column,\r\n  closeController,\r\n}: FilterOperatorControllerProps<TData>) {\r\n  const filter = column.getFilterValue() as FilterModel<'option', TData>\r\n  const filterDetails = optionFilterDetails[filter.operator]\r\n\r\n  const relatedFilters = Object.values(optionFilterDetails).filter(\r\n    (o) => o.target === filterDetails.target,\r\n  )\r\n\r\n  const changeOperator = (value: string) => {\r\n    column.setFilterValue((old: typeof filter) => ({ ...old, operator: value }))\r\n    closeController()\r\n  }\r\n\r\n  return (\r\n    <CommandGroup heading=\"Operators\">\r\n      {relatedFilters.map((r) => {\r\n        return (\r\n          <CommandItem onSelect={changeOperator} value={r.value} key={r.value}>\r\n            {r.label}\r\n          </CommandItem>\r\n        )\r\n      })}\r\n    </CommandGroup>\r\n  )\r\n}\r\n\r\nfunction FilterOperatorMultiOptionController<TData>({\r\n  column,\r\n  closeController,\r\n}: FilterOperatorControllerProps<TData>) {\r\n  const filter = column.getFilterValue() as FilterModel<'multiOption', TData>\r\n  const filterDetails = multiOptionFilterDetails[filter.operator]\r\n\r\n  const relatedFilters = Object.values(multiOptionFilterDetails).filter(\r\n    (o) => o.target === filterDetails.target,\r\n  )\r\n\r\n  const changeOperator = (value: string) => {\r\n    column.setFilterValue((old: typeof filter) => ({ ...old, operator: value }))\r\n    closeController()\r\n  }\r\n\r\n  return (\r\n    <CommandGroup heading=\"Operators\">\r\n      {relatedFilters.map((r) => {\r\n        return (\r\n          <CommandItem onSelect={changeOperator} value={r.value} key={r.value}>\r\n            {r.label}\r\n          </CommandItem>\r\n        )\r\n      })}\r\n    </CommandGroup>\r\n  )\r\n}\r\n\r\nfunction FilterOperatorDateController<TData>({\r\n  column,\r\n  closeController,\r\n}: FilterOperatorControllerProps<TData>) {\r\n  const filter = column.getFilterValue() as FilterModel<'date', TData>\r\n  const filterDetails = dateFilterDetails[filter.operator]\r\n\r\n  const relatedFilters = Object.values(dateFilterDetails).filter(\r\n    (o) => o.target === filterDetails.target,\r\n  )\r\n\r\n  const changeOperator = (value: string) => {\r\n    column.setFilterValue((old: typeof filter) => ({ ...old, operator: value }))\r\n    closeController()\r\n  }\r\n\r\n  return (\r\n    <CommandGroup>\r\n      {relatedFilters.map((r) => {\r\n        return (\r\n          <CommandItem onSelect={changeOperator} value={r.value} key={r.value}>\r\n            {r.label}\r\n          </CommandItem>\r\n        )\r\n      })}\r\n    </CommandGroup>\r\n  )\r\n}\r\n\r\nexport function FilterOperatorTextController<TData>({\r\n  column,\r\n  closeController,\r\n}: FilterOperatorControllerProps<TData>) {\r\n  const filter = column.getFilterValue() as FilterModel<'text', TData>\r\n  const filterDetails = textFilterDetails[filter.operator]\r\n\r\n  const relatedFilters = Object.values(textFilterDetails).filter(\r\n    (o) => o.target === filterDetails.target,\r\n  )\r\n\r\n  const changeOperator = (value: string) => {\r\n    column.setFilterValue((old: typeof filter) => ({ ...old, operator: value }))\r\n    closeController()\r\n  }\r\n\r\n  return (\r\n    <CommandGroup heading=\"Operators\">\r\n      {relatedFilters.map((r) => {\r\n        return (\r\n          <CommandItem onSelect={changeOperator} value={r.value} key={r.value}>\r\n            {r.label}\r\n          </CommandItem>\r\n        )\r\n      })}\r\n    </CommandGroup>\r\n  )\r\n}\r\n\r\nfunction FilterOperatorNumberController<TData>({\r\n  column,\r\n  closeController,\r\n}: FilterOperatorControllerProps<TData>) {\r\n  const filter = column.getFilterValue() as FilterModel<'number', TData>\r\n\r\n  // Show all related operators\r\n  const relatedFilters = Object.values(numberFilterDetails)\r\n  const relatedFilterOperators = relatedFilters.map((r) => r.value)\r\n\r\n  const changeOperator = (value: (typeof relatedFilterOperators)[number]) => {\r\n    column.setFilterValue((old: typeof filter) => {\r\n      // Clear out the second value when switching to single-input operators\r\n      const target = numberFilterDetails[value].target\r\n\r\n      const newValues =\r\n        target === 'single' ? [old.values[0]] : createNumberRange(old.values)\r\n\r\n      return { ...old, operator: value, values: newValues }\r\n    })\r\n    closeController()\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      <CommandGroup heading=\"Operators\">\r\n        {relatedFilters.map((r) => (\r\n          <CommandItem\r\n            onSelect={() => changeOperator(r.value)}\r\n            value={r.value}\r\n            key={r.value}\r\n          >\r\n            {r.label} {/**/}\r\n          </CommandItem>\r\n        ))}\r\n      </CommandGroup>\r\n    </div>\r\n  )\r\n}\r\n\r\n/****** Property Filter Value ******/\r\n\r\nexport function FilterValue<TData, TValue>({\r\n  id,\r\n  column,\r\n  columnMeta,\r\n  table,\r\n}: {\r\n  id: string\r\n  column: Column<TData>\r\n  columnMeta: ColumnMeta<TData, TValue>\r\n  table: Table<TData>\r\n}) {\r\n  return (\r\n    <Popover>\r\n      <PopoverAnchor className=\"h-full\" />\r\n      <PopoverTrigger asChild>\r\n        <Button\r\n          variant=\"ghost\"\r\n          className=\"m-0 h-full w-fit whitespace-nowrap rounded-none p-0 px-2 text-xs\"\r\n        >\r\n          <FilterValueDisplay\r\n            id={id}\r\n            column={column}\r\n            columnMeta={columnMeta}\r\n            table={table}\r\n          />\r\n        </Button>\r\n      </PopoverTrigger>\r\n      <PopoverContent\r\n        align=\"start\"\r\n        side=\"bottom\"\r\n        className=\"w-fit p-0 origin-(--radix-popover-content-transform-origin)\"\r\n      >\r\n        <FitlerValueController\r\n          id={id}\r\n          column={column}\r\n          columnMeta={columnMeta}\r\n          table={table}\r\n        />\r\n      </PopoverContent>\r\n    </Popover>\r\n  )\r\n}\r\n\r\ninterface FilterValueDisplayProps<TData, TValue> {\r\n  id: string\r\n  column: Column<TData>\r\n  columnMeta: ColumnMeta<TData, TValue>\r\n  table: Table<TData>\r\n}\r\n\r\nexport function FilterValueDisplay<TData, TValue>({\r\n  id,\r\n  column,\r\n  columnMeta,\r\n  table,\r\n}: FilterValueDisplayProps<TData, TValue>) {\r\n  switch (columnMeta.type) {\r\n    case 'option':\r\n      return (\r\n        <FilterValueOptionDisplay\r\n          id={id}\r\n          column={column}\r\n          columnMeta={columnMeta}\r\n          table={table}\r\n        />\r\n      )\r\n    case 'multiOption':\r\n      return (\r\n        <FilterValueMultiOptionDisplay\r\n          id={id}\r\n          column={column}\r\n          columnMeta={columnMeta}\r\n          table={table}\r\n        />\r\n      )\r\n    case 'date':\r\n      return (\r\n        <FilterValueDateDisplay\r\n          id={id}\r\n          column={column}\r\n          columnMeta={columnMeta}\r\n          table={table}\r\n        />\r\n      )\r\n    case 'text':\r\n      return (\r\n        <FilterValueTextDisplay\r\n          id={id}\r\n          column={column}\r\n          columnMeta={columnMeta}\r\n          table={table}\r\n        />\r\n      )\r\n    case 'number':\r\n      return (\r\n        <FilterValueNumberDisplay\r\n          id={id}\r\n          column={column}\r\n          columnMeta={columnMeta}\r\n          table={table}\r\n        />\r\n      )\r\n    default:\r\n      return null\r\n  }\r\n}\r\n\r\nexport function FilterValueOptionDisplay<TData, TValue>({\r\n  id,\r\n  column,\r\n  columnMeta,\r\n  table,\r\n}: FilterValueDisplayProps<TData, TValue>) {\r\n  let options: ColumnOption[]\r\n  const columnVals = table\r\n    .getCoreRowModel()\r\n    .rows.flatMap((r) => r.getValue<TValue>(id))\r\n    .filter((v): v is NonNullable<TValue> => v !== undefined && v !== null)\r\n  const uniqueVals = uniq(columnVals)\r\n\r\n  // If static options are provided, use them\r\n  if (columnMeta.options) {\r\n    options = columnMeta.options\r\n  }\r\n\r\n  // No static options provided,\r\n  // We should dynamically generate them based on the column data\r\n  else if (columnMeta.transformOptionFn) {\r\n    const transformOptionFn = columnMeta.transformOptionFn\r\n\r\n    options = uniqueVals.map((v) =>\r\n      transformOptionFn(v as ElementType<NonNullable<TValue>>),\r\n    )\r\n  }\r\n\r\n  // Make sure the column data conforms to ColumnOption type\r\n  else if (isColumnOptionArray(uniqueVals)) {\r\n    options = uniqueVals\r\n  }\r\n\r\n  // Invalid configuration\r\n  else {\r\n    throw new Error(\r\n      `[data-table-filter] [${id}] Either provide static options, a transformOptionFn, or ensure the column data conforms to ColumnOption type`,\r\n    )\r\n  }\r\n\r\n  const filter = column.getFilterValue() as FilterModel<'option', TData>\r\n  const selected = options.filter((o) => filter?.values.includes(o.value))\r\n\r\n  // We display the selected options based on how many are selected\r\n  //\r\n  // If there is only one option selected, we display its icon and label\r\n  //\r\n  // If there are multiple options selected, we display:\r\n  // 1) up to 3 icons of the selected options\r\n  // 2) the number of selected options\r\n  if (selected.length === 1) {\r\n    const { label, icon: Icon } = selected[0]\r\n    const hasIcon = !!Icon\r\n    return (\r\n      <span className=\"inline-flex items-center gap-1\">\r\n        {hasIcon &&\r\n          (isValidElement(Icon) ? (\r\n            Icon\r\n          ) : (\r\n            <Icon className=\"size-4 text-primary\" />\r\n          ))}\r\n        <span>{label}</span>\r\n      </span>\r\n    )\r\n  }\r\n  const name = columnMeta.displayName.toLowerCase()\r\n  const pluralName = name.endsWith('s') ? `${name}es` : `${name}s`\r\n\r\n  const hasOptionIcons = !options?.some((o) => !o.icon)\r\n\r\n  return (\r\n    <div className=\"inline-flex items-center gap-0.5\">\r\n      {hasOptionIcons &&\r\n        take(selected, 3).map(({ value, icon }) => {\r\n          const Icon = icon!\r\n          return isValidElement(Icon) ? (\r\n            Icon\r\n          ) : (\r\n            <Icon key={value} className=\"size-4\" />\r\n          )\r\n        })}\r\n      <span className={cn(hasOptionIcons && 'ml-1.5')}>\r\n        {selected.length} {pluralName}\r\n      </span>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport function FilterValueMultiOptionDisplay<TData, TValue>({\r\n  id,\r\n  column,\r\n  columnMeta,\r\n  table,\r\n}: FilterValueDisplayProps<TData, TValue>) {\r\n  let options: ColumnOption[]\r\n  const columnVals = table\r\n    .getCoreRowModel()\r\n    .rows.flatMap((r) => r.getValue<TValue>(id))\r\n    .filter((v): v is NonNullable<TValue> => v !== undefined && v !== null)\r\n  const uniqueVals = uniq(columnVals)\r\n\r\n  // If static options are provided, use them\r\n  if (columnMeta.options) {\r\n    options = columnMeta.options\r\n  }\r\n\r\n  // No static options provided,\r\n  // We should dynamically generate them based on the column data\r\n  else if (columnMeta.transformOptionFn) {\r\n    const transformOptionFn = columnMeta.transformOptionFn\r\n\r\n    options = uniqueVals.map((v) =>\r\n      transformOptionFn(v as ElementType<NonNullable<TValue>>),\r\n    )\r\n  }\r\n\r\n  // Make sure the column data conforms to ColumnOption type\r\n  else if (isColumnOptionArray(uniqueVals)) {\r\n    options = uniqueVals\r\n  }\r\n\r\n  // Invalid configuration\r\n  else {\r\n    throw new Error(\r\n      `[data-table-filter] [${id}] Either provide static options, a transformOptionFn, or ensure the column data conforms to ColumnOption type`,\r\n    )\r\n  }\r\n\r\n  const filter = column.getFilterValue() as FilterModel<'multiOption', TData>\r\n  const selected = options.filter((o) => filter?.values[0].includes(o.value))\r\n\r\n  if (selected.length === 1) {\r\n    const { label, icon: Icon } = selected[0]\r\n    const hasIcon = !!Icon\r\n    return (\r\n      <span className=\"inline-flex items-center gap-1.5\">\r\n        {hasIcon &&\r\n          (isValidElement(Icon) ? (\r\n            Icon\r\n          ) : (\r\n            <Icon className=\"size-4 text-primary\" />\r\n          ))}\r\n\r\n        <span>{label}</span>\r\n      </span>\r\n    )\r\n  }\r\n\r\n  const name = columnMeta.displayName.toLowerCase()\r\n\r\n  const hasOptionIcons = !columnMeta.options?.some((o) => !o.icon)\r\n\r\n  return (\r\n    <div className=\"inline-flex items-center gap-1.5\">\r\n      {hasOptionIcons && (\r\n        <div key=\"icons\" className=\"inline-flex items-center gap-0.5\">\r\n          {take(selected, 3).map(({ value, icon }) => {\r\n            const Icon = icon!\r\n            return isValidElement(Icon) ? (\r\n              cloneElement(Icon, { key: value })\r\n            ) : (\r\n              <Icon key={value} className=\"size-4\" />\r\n            )\r\n          })}\r\n        </div>\r\n      )}\r\n      <span>\r\n        {selected.length} {name}\r\n      </span>\r\n    </div>\r\n  )\r\n}\r\n\r\nfunction formatDateRange(start: Date, end: Date) {\r\n  const sameMonth = start.getMonth() === end.getMonth()\r\n  const sameYear = start.getFullYear() === end.getFullYear()\r\n\r\n  if (sameMonth && sameYear) {\r\n    return `${format(start, 'MMM d')} - ${format(end, 'd, yyyy')}`\r\n  }\r\n\r\n  if (sameYear) {\r\n    return `${format(start, 'MMM d')} - ${format(end, 'MMM d, yyyy')}`\r\n  }\r\n\r\n  return `${format(start, 'MMM d, yyyy')} - ${format(end, 'MMM d, yyyy')}`\r\n}\r\n\r\nexport function FilterValueDateDisplay<TData, TValue>({\r\n  column,\r\n}: FilterValueDisplayProps<TData, TValue>) {\r\n  const filter = column.getFilterValue()\r\n    ? (column.getFilterValue() as FilterModel<'date', TData>)\r\n    : undefined\r\n\r\n  if (!filter) return null\r\n  if (filter.values.length === 0) return <Ellipsis className=\"size-4\" />\r\n  if (filter.values.length === 1) {\r\n    const value = filter.values[0]\r\n\r\n    const formattedDateStr = format(value, 'MMM d, yyyy')\r\n\r\n    return <span>{formattedDateStr}</span>\r\n  }\r\n\r\n  const formattedRangeStr = formatDateRange(filter.values[0], filter.values[1])\r\n\r\n  return <span>{formattedRangeStr}</span>\r\n}\r\n\r\nexport function FilterValueTextDisplay<TData, TValue>({\r\n  column,\r\n}: FilterValueDisplayProps<TData, TValue>) {\r\n  const filter = column.getFilterValue()\r\n    ? (column.getFilterValue() as FilterModel<'text', TData>)\r\n    : undefined\r\n\r\n  if (!filter) return null\r\n  if (filter.values.length === 0 || filter.values[0].trim() === '')\r\n    return <Ellipsis className=\"size-4\" />\r\n\r\n  const value = filter.values[0]\r\n\r\n  return <span>{value}</span>\r\n}\r\n\r\nexport function FilterValueNumberDisplay<TData, TValue>({\r\n  column,\r\n  columnMeta,\r\n}: FilterValueDisplayProps<TData, TValue>) {\r\n  const maxFromMeta = columnMeta.max\r\n  const cappedMax = maxFromMeta ?? 2147483647\r\n\r\n  const filter = column.getFilterValue()\r\n    ? (column.getFilterValue() as FilterModel<'number', TData>)\r\n    : undefined\r\n\r\n  if (!filter) return null\r\n\r\n  if (\r\n    filter.operator === 'is between' ||\r\n    filter.operator === 'is not between'\r\n  ) {\r\n    const minValue = filter.values[0]\r\n    const maxValue =\r\n      filter.values[1] === Number.POSITIVE_INFINITY ||\r\n      filter.values[1] >= cappedMax\r\n        ? `${cappedMax}+`\r\n        : filter.values[1]\r\n\r\n    return (\r\n      <span className=\"tabular-nums tracking-tight\">\r\n        {minValue} and {maxValue}\r\n      </span>\r\n    )\r\n  }\r\n\r\n  if (!filter.values || filter.values.length === 0) {\r\n    return null\r\n  }\r\n\r\n  const value = filter.values[0]\r\n  return <span className=\"tabular-nums tracking-tight\">{value}</span>\r\n}\r\n\r\nexport function FitlerValueController<TData, TValue>({\r\n  id,\r\n  column,\r\n  columnMeta,\r\n  table,\r\n}: {\r\n  id: string\r\n  column: Column<TData>\r\n  columnMeta: ColumnMeta<TData, TValue>\r\n  table: Table<TData>\r\n}) {\r\n  switch (columnMeta.type) {\r\n    case 'option':\r\n      return (\r\n        <FilterValueOptionController\r\n          id={id}\r\n          column={column}\r\n          columnMeta={columnMeta}\r\n          table={table}\r\n        />\r\n      )\r\n    case 'multiOption':\r\n      return (\r\n        <FilterValueMultiOptionController\r\n          id={id}\r\n          column={column}\r\n          columnMeta={columnMeta}\r\n          table={table}\r\n        />\r\n      )\r\n    case 'date':\r\n      return (\r\n        <FilterValueDateController\r\n          id={id}\r\n          column={column}\r\n          columnMeta={columnMeta}\r\n          table={table}\r\n        />\r\n      )\r\n    case 'text':\r\n      return (\r\n        <FilterValueTextController\r\n          id={id}\r\n          column={column}\r\n          columnMeta={columnMeta}\r\n          table={table}\r\n        />\r\n      )\r\n    case 'number':\r\n      return (\r\n        <FilterValueNumberController\r\n          id={id}\r\n          column={column}\r\n          columnMeta={columnMeta}\r\n          table={table}\r\n        />\r\n      )\r\n    default:\r\n      return null\r\n  }\r\n}\r\n\r\ninterface ProperFilterValueMenuProps<TData, TValue> {\r\n  id: string\r\n  column: Column<TData>\r\n  columnMeta: ColumnMeta<TData, TValue>\r\n  table: Table<TData>\r\n}\r\n\r\nexport function FilterValueOptionController<TData, TValue>({\r\n  id,\r\n  column,\r\n  columnMeta,\r\n  table,\r\n}: ProperFilterValueMenuProps<TData, TValue>) {\r\n  const filter = column.getFilterValue()\r\n    ? (column.getFilterValue() as FilterModel<'option', TData>)\r\n    : undefined\r\n\r\n  let options: ColumnOption[]\r\n  const columnVals = table\r\n    .getCoreRowModel()\r\n    .rows.flatMap((r) => r.getValue<TValue>(id))\r\n    .filter((v): v is NonNullable<TValue> => v !== undefined && v !== null)\r\n  const uniqueVals = uniq(columnVals)\r\n\r\n  // If static options are provided, use them\r\n  if (columnMeta.options) {\r\n    options = columnMeta.options\r\n  }\r\n\r\n  // No static options provided,\r\n  // We should dynamically generate them based on the column data\r\n  else if (columnMeta.transformOptionFn) {\r\n    const transformOptionFn = columnMeta.transformOptionFn\r\n\r\n    options = uniqueVals.map((v) =>\r\n      transformOptionFn(v as ElementType<NonNullable<TValue>>),\r\n    )\r\n  }\r\n\r\n  // Make sure the column data conforms to ColumnOption type\r\n  else if (isColumnOptionArray(uniqueVals)) {\r\n    options = uniqueVals\r\n  }\r\n\r\n  // Invalid configuration\r\n  else {\r\n    throw new Error(\r\n      `[data-table-filter] [${id}] Either provide static options, a transformOptionFn, or ensure the column data conforms to ColumnOption type`,\r\n    )\r\n  }\r\n\r\n  const optionsCount: Record<ColumnOption['value'], number> = columnVals.reduce(\r\n    (acc, curr) => {\r\n      const { value } = columnMeta.transformOptionFn\r\n        ? columnMeta.transformOptionFn(curr as ElementType<NonNullable<TValue>>)\r\n        : { value: curr as string }\r\n\r\n      acc[value] = (acc[value] ?? 0) + 1\r\n      return acc\r\n    },\r\n    {} as Record<ColumnOption['value'], number>,\r\n  )\r\n\r\n  function handleOptionSelect(value: string, check: boolean) {\r\n    if (check)\r\n      column?.setFilterValue(\r\n        (old: undefined | FilterModel<'option', TData>) => {\r\n          if (!old || old.values.length === 0)\r\n            return {\r\n              operator: 'is',\r\n              values: [value],\r\n              columnMeta: column.columnDef.meta,\r\n            } satisfies FilterModel<'option', TData>\r\n\r\n          const newValues = [...old.values, value]\r\n\r\n          return {\r\n            operator: 'is any of',\r\n            values: newValues,\r\n            columnMeta: column.columnDef.meta,\r\n          } satisfies FilterModel<'option', TData>\r\n        },\r\n      )\r\n    else\r\n      column?.setFilterValue(\r\n        (old: undefined | FilterModel<'option', TData>) => {\r\n          if (!old || old.values.length <= 1) return undefined\r\n\r\n          const newValues = old.values.filter((v) => v !== value)\r\n          return {\r\n            operator: newValues.length > 1 ? 'is any of' : 'is',\r\n            values: newValues,\r\n            columnMeta: column.columnDef.meta,\r\n          } satisfies FilterModel<'option', TData>\r\n        },\r\n      )\r\n  }\r\n\r\n  return (\r\n    <Command loop>\r\n      <CommandInput autoFocus placeholder=\"Search...\" />\r\n      <CommandEmpty>No results.</CommandEmpty>\r\n      <CommandList className=\"max-h-fit\">\r\n        <CommandGroup>\r\n          {options.map((v) => {\r\n            const checked = Boolean(filter?.values.includes(v.value))\r\n            const count = optionsCount[v.value] ?? 0\r\n\r\n            return (\r\n              <CommandItem\r\n                key={v.value}\r\n                onSelect={() => {\r\n                  handleOptionSelect(v.value, !checked)\r\n                }}\r\n                className=\"group flex items-center justify-between gap-1.5\"\r\n              >\r\n                <div className=\"flex items-center gap-1.5\">\r\n                  <Checkbox\r\n                    checked={checked}\r\n                    className=\"opacity-0 group-hover:opacity-100 data-[state=checked]:opacity-100\"\r\n                  />\r\n                  {v.icon &&\r\n                    (isValidElement(v.icon) ? (\r\n                      v.icon\r\n                    ) : (\r\n                      <v.icon className=\"size-4 text-primary\" />\r\n                    ))}\r\n                  <span>\r\n                    {v.label}\r\n                    <sup\r\n                      className={cn(\r\n                        'ml-0.5 tabular-nums tracking-tight text-muted-foreground',\r\n                        count === 0 && 'slashed-zero',\r\n                      )}\r\n                    >\r\n                      {count < 100 ? count : '100+'}\r\n                    </sup>\r\n                  </span>\r\n                </div>\r\n              </CommandItem>\r\n            )\r\n          })}\r\n        </CommandGroup>\r\n      </CommandList>\r\n    </Command>\r\n  )\r\n}\r\n\r\nexport function FilterValueMultiOptionController<\r\n  TData extends RowData,\r\n  TValue,\r\n>({\r\n  id,\r\n  column,\r\n  columnMeta,\r\n  table,\r\n}: ProperFilterValueMenuProps<TData, TValue>) {\r\n  const filter = column.getFilterValue() as\r\n    | FilterModel<'multiOption', TData>\r\n    | undefined\r\n\r\n  let options: ColumnOption[]\r\n  const columnVals = table\r\n    .getCoreRowModel()\r\n    .rows.flatMap((r) => r.getValue<TValue>(id))\r\n    .filter((v): v is NonNullable<TValue> => v !== undefined && v !== null)\r\n  const uniqueVals = uniq(columnVals)\r\n\r\n  // If static options are provided, use them\r\n  if (columnMeta.options) {\r\n    options = columnMeta.options\r\n  }\r\n\r\n  // No static options provided,\r\n  // We should dynamically generate them based on the column data\r\n  else if (columnMeta.transformOptionFn) {\r\n    const transformOptionFn = columnMeta.transformOptionFn\r\n\r\n    options = uniqueVals.map((v) =>\r\n      transformOptionFn(v as ElementType<NonNullable<TValue>>),\r\n    )\r\n  }\r\n\r\n  // Make sure the column data conforms to ColumnOption type\r\n  else if (isColumnOptionArray(uniqueVals)) {\r\n    options = uniqueVals\r\n  }\r\n\r\n  // Invalid configuration\r\n  else {\r\n    throw new Error(\r\n      `[data-table-filter] [${id}] Either provide static options, a transformOptionFn, or ensure the column data conforms to ColumnOption type`,\r\n    )\r\n  }\r\n\r\n  const optionsCount: Record<ColumnOption['value'], number> = columnVals.reduce(\r\n    (acc, curr) => {\r\n      const value = columnMeta.options\r\n        ? (curr as string)\r\n        : columnMeta.transformOptionFn!(\r\n            curr as ElementType<NonNullable<TValue>>,\r\n          ).value\r\n\r\n      acc[value] = (acc[value] ?? 0) + 1\r\n      return acc\r\n    },\r\n    {} as Record<ColumnOption['value'], number>,\r\n  )\r\n\r\n  // Handles the selection/deselection of an option\r\n  function handleOptionSelect(value: string, check: boolean) {\r\n    if (check) {\r\n      column.setFilterValue(\r\n        (old: undefined | FilterModel<'multiOption', TData>) => {\r\n          if (\r\n            !old ||\r\n            old.values.length === 0 ||\r\n            !old.values[0] ||\r\n            old.values[0].length === 0\r\n          )\r\n            return {\r\n              operator: 'include',\r\n              values: [[value]],\r\n              columnMeta: column.columnDef.meta,\r\n            } satisfies FilterModel<'multiOption', TData>\r\n\r\n          const newValues = [uniq([...old.values[0], value])]\r\n\r\n          return {\r\n            operator: determineNewOperator(\r\n              'multiOption',\r\n              old.values,\r\n              newValues,\r\n              old.operator,\r\n            ),\r\n            values: newValues,\r\n            columnMeta: column.columnDef.meta,\r\n          } satisfies FilterModel<'multiOption', TData>\r\n        },\r\n      )\r\n    } else\r\n      column.setFilterValue(\r\n        (old: undefined | FilterModel<'multiOption', TData>) => {\r\n          if (!old?.values[0] || old.values[0].length <= 1) return undefined\r\n\r\n          const newValues = [\r\n            uniq([...old.values[0], value]).filter((v) => v !== value),\r\n          ]\r\n\r\n          return {\r\n            operator: determineNewOperator(\r\n              'multiOption',\r\n              old.values,\r\n              newValues,\r\n              old.operator,\r\n            ),\r\n            values: newValues,\r\n            columnMeta: column.columnDef.meta,\r\n          } satisfies FilterModel<'multiOption', TData>\r\n        },\r\n      )\r\n  }\r\n\r\n  return (\r\n    <Command loop>\r\n      <CommandInput autoFocus placeholder=\"Search...\" />\r\n      <CommandEmpty>No results.</CommandEmpty>\r\n      <CommandList>\r\n        <CommandGroup>\r\n          {options.map((v) => {\r\n            const checked = Boolean(filter?.values[0]?.includes(v.value))\r\n            const count = optionsCount[v.value] ?? 0\r\n\r\n            return (\r\n              <CommandItem\r\n                key={v.value}\r\n                onSelect={() => {\r\n                  handleOptionSelect(v.value, !checked)\r\n                }}\r\n                className=\"group flex items-center justify-between gap-1.5\"\r\n              >\r\n                <div className=\"flex items-center gap-1.5\">\r\n                  <Checkbox\r\n                    checked={checked}\r\n                    className=\"opacity-0 group-hover:opacity-100 data-[state=checked]:opacity-100\"\r\n                  />\r\n                  {v.icon &&\r\n                    (isValidElement(v.icon) ? (\r\n                      v.icon\r\n                    ) : (\r\n                      <v.icon className=\"size-4 text-primary\" />\r\n                    ))}\r\n                  <span>\r\n                    {v.label}\r\n                    <sup\r\n                      className={cn(\r\n                        'ml-0.5 tabular-nums tracking-tight text-muted-foreground',\r\n                        count === 0 && 'slashed-zero',\r\n                      )}\r\n                    >\r\n                      {count < 100 ? count : '100+'}\r\n                    </sup>\r\n                  </span>\r\n                </div>\r\n              </CommandItem>\r\n            )\r\n          })}\r\n        </CommandGroup>\r\n      </CommandList>\r\n    </Command>\r\n  )\r\n}\r\n\r\nexport function FilterValueDateController<TData, TValue>({\r\n  column,\r\n}: ProperFilterValueMenuProps<TData, TValue>) {\r\n  const filter = column.getFilterValue()\r\n    ? (column.getFilterValue() as FilterModel<'date', TData>)\r\n    : undefined\r\n\r\n  const [date, setDate] = useState<DateRange | undefined>({\r\n    from: filter?.values[0] ?? new Date(),\r\n    to: filter?.values[1] ?? undefined,\r\n  })\r\n\r\n  function changeDateRange(value: DateRange | undefined) {\r\n    const start = value?.from\r\n    const end =\r\n      start && value && value.to && !isEqual(start, value.to)\r\n        ? value.to\r\n        : undefined\r\n\r\n    setDate({ from: start, to: end })\r\n\r\n    const isRange = start && end\r\n\r\n    const newValues = isRange ? [start, end] : start ? [start] : []\r\n\r\n    column.setFilterValue((old: undefined | FilterModel<'date', TData>) => {\r\n      if (!old || old.values.length === 0)\r\n        return {\r\n          operator: newValues.length > 1 ? 'is between' : 'is',\r\n          values: newValues,\r\n          columnMeta: column.columnDef.meta,\r\n        } satisfies FilterModel<'date', TData>\r\n\r\n      return {\r\n        operator:\r\n          old.values.length < newValues.length\r\n            ? 'is between'\r\n            : old.values.length > newValues.length\r\n              ? 'is'\r\n              : old.operator,\r\n        values: newValues,\r\n        columnMeta: column.columnDef.meta,\r\n      } satisfies FilterModel<'date', TData>\r\n    })\r\n  }\r\n\r\n  return (\r\n    <Command>\r\n      {/* <CommandInput placeholder=\"Search...\" /> */}\r\n      {/* <CommandEmpty>No results.</CommandEmpty> */}\r\n      <CommandList className=\"max-h-fit\">\r\n        <CommandGroup>\r\n          <div>\r\n            <Calendar\r\n              initialFocus\r\n              mode=\"range\"\r\n              defaultMonth={date?.from}\r\n              selected={date}\r\n              onSelect={changeDateRange}\r\n              numberOfMonths={1}\r\n            />\r\n          </div>\r\n        </CommandGroup>\r\n      </CommandList>\r\n    </Command>\r\n  )\r\n}\r\n\r\nexport function FilterValueTextController<TData, TValue>({\r\n  column,\r\n}: ProperFilterValueMenuProps<TData, TValue>) {\r\n  const filter = column.getFilterValue()\r\n    ? (column.getFilterValue() as FilterModel<'text', TData>)\r\n    : undefined\r\n\r\n  const changeText = (value: string | number) => {\r\n    column.setFilterValue((old: undefined | FilterModel<'text', TData>) => {\r\n      if (!old || old.values.length === 0)\r\n        return {\r\n          operator: 'contains',\r\n          values: [String(value)],\r\n          columnMeta: column.columnDef.meta,\r\n        } satisfies FilterModel<'text', TData>\r\n      return { operator: old.operator, values: [String(value)] }\r\n    })\r\n  }\r\n\r\n  return (\r\n    <Command>\r\n      <CommandList className=\"max-h-fit\">\r\n        <CommandGroup>\r\n          <CommandItem>\r\n            <DebouncedInput\r\n              placeholder=\"Search...\"\r\n              autoFocus\r\n              value={filter?.values[0] ?? ''}\r\n              onChange={changeText}\r\n            />\r\n          </CommandItem>\r\n        </CommandGroup>\r\n      </CommandList>\r\n    </Command>\r\n  )\r\n}\r\n\r\nexport function FilterValueNumberController<TData, TValue>({\r\n  table,\r\n  column,\r\n  columnMeta,\r\n}: ProperFilterValueMenuProps<TData, TValue>) {\r\n  const maxFromMeta = columnMeta.max\r\n  const cappedMax = maxFromMeta ?? Number.MAX_SAFE_INTEGER\r\n\r\n  const filter = column.getFilterValue()\r\n    ? (column.getFilterValue() as FilterModel<'number', TData>)\r\n    : undefined\r\n\r\n  const isNumberRange =\r\n    !!filter && numberFilterDetails[filter.operator].target === 'multiple'\r\n\r\n  const [datasetMin] = column.getFacetedMinMaxValues() ?? [0, 0]\r\n\r\n  const initialValues = () => {\r\n    if (filter?.values) {\r\n      return filter.values.map((val) =>\r\n        val >= cappedMax ? `${cappedMax}+` : val.toString(),\r\n      )\r\n    }\r\n    return [datasetMin.toString()]\r\n  }\r\n\r\n  const [inputValues, setInputValues] = useState<string[]>(initialValues)\r\n\r\n  const changeNumber = (value: number[]) => {\r\n    const sortedValues = [...value].sort((a, b) => a - b)\r\n\r\n    column.setFilterValue((old: undefined | FilterModel<'number', TData>) => {\r\n      if (!old || old.values.length === 0) {\r\n        return {\r\n          operator: 'is',\r\n          values: sortedValues,\r\n        }\r\n      }\r\n\r\n      const operator = numberFilterDetails[old.operator]\r\n      let newValues: number[]\r\n\r\n      if (operator.target === 'single') {\r\n        newValues = [sortedValues[0]]\r\n      } else {\r\n        newValues = [\r\n          sortedValues[0] >= cappedMax ? cappedMax : sortedValues[0],\r\n          sortedValues[1] >= cappedMax\r\n            ? Number.POSITIVE_INFINITY\r\n            : sortedValues[1],\r\n        ]\r\n      }\r\n\r\n      return {\r\n        operator: old.operator,\r\n        values: newValues,\r\n      }\r\n    })\r\n  }\r\n\r\n  const handleInputChange = (index: number, value: string) => {\r\n    const newValues = [...inputValues]\r\n    if (isNumberRange && Number.parseInt(value, 10) >= cappedMax) {\r\n      newValues[index] = `${cappedMax}+`\r\n    } else {\r\n      newValues[index] = value\r\n    }\r\n\r\n    setInputValues(newValues)\r\n\r\n    const parsedValues = newValues.map((val) => {\r\n      if (val.trim() === '') return 0\r\n      if (val === `${cappedMax}+`) return cappedMax\r\n      return Number.parseInt(val, 10)\r\n    })\r\n\r\n    changeNumber(parsedValues)\r\n  }\r\n\r\n  const changeType = (type: 'single' | 'range') => {\r\n    column.setFilterValue((old: undefined | FilterModel<'number', TData>) => {\r\n      if (type === 'single') {\r\n        return {\r\n          operator: 'is',\r\n          values: [old?.values[0] ?? 0],\r\n        }\r\n      }\r\n      const newMaxValue = old?.values[0] ?? cappedMax\r\n      return {\r\n        operator: 'is between',\r\n        values: [0, newMaxValue],\r\n      }\r\n    })\r\n\r\n    if (type === 'single') {\r\n      setInputValues([inputValues[0]])\r\n    } else {\r\n      const maxValue = inputValues[0] || cappedMax.toString()\r\n      setInputValues(['0', maxValue])\r\n    }\r\n  }\r\n\r\n  const slider = {\r\n    value: inputValues.map((val) =>\r\n      val === '' || val === `${cappedMax}+`\r\n        ? cappedMax\r\n        : Number.parseInt(val, 10),\r\n    ),\r\n    onValueChange: (value: number[]) => {\r\n      const values = value.map((val) => (val >= cappedMax ? cappedMax : val))\r\n      setInputValues(\r\n        values.map((v) => (v >= cappedMax ? `${cappedMax}+` : v.toString())),\r\n      )\r\n      changeNumber(values)\r\n    },\r\n  }\r\n\r\n  return (\r\n    <Command>\r\n      <CommandList className=\"w-[300px] px-2 py-2\">\r\n        <CommandGroup>\r\n          <div className=\"flex flex-col w-full\">\r\n            <Tabs\r\n              value={isNumberRange ? 'range' : 'single'}\r\n              onValueChange={(v) =>\r\n                changeType(v === 'range' ? 'range' : 'single')\r\n              }\r\n            >\r\n              <TabsList className=\"w-full *:text-xs\">\r\n                <TabsTrigger value=\"single\">Single</TabsTrigger>\r\n                <TabsTrigger value=\"range\">Range</TabsTrigger>\r\n              </TabsList>\r\n              <TabsContent value=\"single\" className=\"flex flex-col gap-4 mt-4\">\r\n                <Slider\r\n                  value={[Number(inputValues[0])]}\r\n                  onValueChange={(value) => {\r\n                    handleInputChange(0, value[0].toString())\r\n                  }}\r\n                  min={datasetMin}\r\n                  max={cappedMax}\r\n                  step={1}\r\n                  aria-orientation=\"horizontal\"\r\n                />\r\n                <div className=\"flex items-center gap-2\">\r\n                  <span className=\"text-xs font-medium\">Value</span>\r\n                  <Input\r\n                    id=\"single\"\r\n                    type=\"number\"\r\n                    value={inputValues[0]}\r\n                    onChange={(e) => handleInputChange(0, e.target.value)}\r\n                    max={cappedMax}\r\n                  />\r\n                </div>\r\n              </TabsContent>\r\n              <TabsContent value=\"range\" className=\"flex flex-col gap-4 mt-4\">\r\n                <Slider\r\n                  value={slider.value}\r\n                  onValueChange={slider.onValueChange}\r\n                  min={datasetMin}\r\n                  max={cappedMax}\r\n                  step={1}\r\n                  aria-orientation=\"horizontal\"\r\n                />\r\n                <div className=\"grid grid-cols-2 gap-4\">\r\n                  <div className=\"flex items-center gap-2\">\r\n                    <span className=\"text-xs font-medium\">Min</span>\r\n                    <Input\r\n                      type=\"number\"\r\n                      value={inputValues[0]}\r\n                      onChange={(e) => handleInputChange(0, e.target.value)}\r\n                      max={cappedMax}\r\n                    />\r\n                  </div>\r\n                  <div className=\"flex items-center gap-2\">\r\n                    <span className=\"text-xs font-medium\">Max</span>\r\n                    <Input\r\n                      type=\"text\"\r\n                      value={inputValues[1]}\r\n                      placeholder={`${cappedMax}+`}\r\n                      onChange={(e) => handleInputChange(1, e.target.value)}\r\n                      max={cappedMax}\r\n                    />\r\n                  </div>\r\n                </div>\r\n              </TabsContent>\r\n            </Tabs>\r\n          </div>\r\n        </CommandGroup>\r\n      </CommandList>\r\n    </Command>\r\n  )\r\n}\r\n",
      "type": "registry:component"
    },
    {
      "path": "registry/data-table-filter/lib/array.ts",
      "content": "export function intersection<T>(a: T[], b: T[]): T[] {\r\n  return a.filter((x) => b.includes(x))\r\n}\r\n\r\n/**\r\n * Computes a stable hash string for any value using deep inspection.\r\n * This function recursively builds a string for primitives, arrays, and objects.\r\n * It uses a cache (WeakMap) to avoid rehashing the same object twice, which is\r\n * particularly beneficial if an object appears in multiple places.\r\n */\r\nfunction deepHash(value: any, cache = new WeakMap<object, string>()): string {\r\n  // Handle primitives and null/undefined.\r\n  if (value === null) return 'null'\r\n  if (value === undefined) return 'undefined'\r\n  const type = typeof value\r\n  if (type === 'number' || type === 'boolean' || type === 'string') {\r\n    return `${type}:${value.toString()}`\r\n  }\r\n  if (type === 'function') {\r\n    // Note: using toString for functions.\r\n    return `function:${value.toString()}`\r\n  }\r\n\r\n  // For objects and arrays, use caching to avoid repeated work.\r\n  if (type === 'object') {\r\n    // If weve seen this object before, return the cached hash.\r\n    if (cache.has(value)) {\r\n      return cache.get(value)!\r\n    }\r\n    let hash: string\r\n    if (Array.isArray(value)) {\r\n      // Compute hash for each element in order.\r\n      hash = `array:[${value.map((v) => deepHash(v, cache)).join(',')}]`\r\n    } else {\r\n      // For objects, sort keys to ensure the representation is stable.\r\n      const keys = Object.keys(value).sort()\r\n      const props = keys\r\n        .map((k) => `${k}:${deepHash(value[k], cache)}`)\r\n        .join(',')\r\n      hash = `object:{${props}}`\r\n    }\r\n    cache.set(value, hash)\r\n    return hash\r\n  }\r\n\r\n  // Fallback if no case matched.\r\n  return `${type}:${value.toString()}`\r\n}\r\n\r\n/**\r\n * Performs deep equality check for any two values.\r\n * This recursively checks primitives, arrays, and plain objects.\r\n */\r\nfunction deepEqual(a: any, b: any): boolean {\r\n  // Check strict equality first.\r\n  if (a === b) return true\r\n  // If types differ, theyre not equal.\r\n  if (typeof a !== typeof b) return false\r\n  if (a === null || b === null || a === undefined || b === undefined)\r\n    return false\r\n\r\n  // Check arrays.\r\n  if (Array.isArray(a)) {\r\n    if (!Array.isArray(b) || a.length !== b.length) return false\r\n    for (let i = 0; i < a.length; i++) {\r\n      if (!deepEqual(a[i], b[i])) return false\r\n    }\r\n    return true\r\n  }\r\n\r\n  // Check objects.\r\n  if (typeof a === 'object') {\r\n    if (typeof b !== 'object') return false\r\n    const aKeys = Object.keys(a).sort()\r\n    const bKeys = Object.keys(b).sort()\r\n    if (aKeys.length !== bKeys.length) return false\r\n    for (let i = 0; i < aKeys.length; i++) {\r\n      if (aKeys[i] !== bKeys[i]) return false\r\n      if (!deepEqual(a[aKeys[i]], b[bKeys[i]])) return false\r\n    }\r\n    return true\r\n  }\r\n\r\n  // For any other types (should be primitives by now), use strict equality.\r\n  return false\r\n}\r\n\r\n/**\r\n * Returns a new array containing only the unique values from the input array.\r\n * Uniqueness is determined by deep equality.\r\n *\r\n * @param arr - The array of values to be filtered.\r\n * @returns A new array with duplicates removed.\r\n */\r\nexport function uniq<T>(arr: T[]): T[] {\r\n  // Use a Map where key is the deep hash and value is an array of items sharing the same hash.\r\n  const seen = new Map<string, T[]>()\r\n  const result: T[] = []\r\n\r\n  for (const item of arr) {\r\n    const hash = deepHash(item)\r\n    if (seen.has(hash)) {\r\n      // There is a potential duplicate; check the stored items with the same hash.\r\n      const itemsWithHash = seen.get(hash)!\r\n      let duplicateFound = false\r\n      for (const existing of itemsWithHash) {\r\n        if (deepEqual(existing, item)) {\r\n          duplicateFound = true\r\n          break\r\n        }\r\n      }\r\n      if (!duplicateFound) {\r\n        itemsWithHash.push(item)\r\n        result.push(item)\r\n      }\r\n    } else {\r\n      // First time this hash appears.\r\n      seen.set(hash, [item])\r\n      result.push(item)\r\n    }\r\n  }\r\n\r\n  return result\r\n}\r\n\r\nexport function take<T>(a: T[], n: number): T[] {\r\n  return a.slice(0, n)\r\n}\r\n\r\nexport function flatten<T>(a: T[][]): T[] {\r\n  return a.flat()\r\n}\r\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/data-table-filter/lib/filters.ts",
      "content": "import '@tanstack/table-core'\r\nimport type { AccessorFn, Column, Row, RowData } from '@tanstack/react-table'\r\nimport type { ColumnMeta, Table } from '@tanstack/react-table'\r\nimport {\r\n  endOfDay,\r\n  isAfter,\r\n  isBefore,\r\n  isSameDay,\r\n  isWithinInterval,\r\n  startOfDay,\r\n} from 'date-fns'\r\nimport type { LucideIcon } from 'lucide-react'\r\nimport { intersection, uniq } from './array'\r\n\r\nexport type ElementType<T> = T extends (infer U)[] ? U : T\r\n\r\ndeclare module '@tanstack/react-table' {\r\n  interface ColumnMeta<TData extends RowData, TValue> {\r\n    /* The display name of the column. */\r\n    displayName: string\r\n\r\n    /* The column icon. */\r\n    icon: LucideIcon\r\n\r\n    /* The data type of the column. */\r\n    type: ColumnDataType\r\n\r\n    /* An optional list of options for the column. */\r\n    /* This is used for columns with type 'option' or 'multiOption'. */\r\n    /* If the options are known ahead of time, they can be defined here. */\r\n    /* Otherwise, they will be dynamically generated based on the data. */\r\n    options?: ColumnOption[]\r\n\r\n    /* An optional function to transform columns with type 'option' or 'multiOption'. */\r\n    /* This is used to convert each raw option into a ColumnOption. */\r\n    transformOptionFn?: (\r\n      value: ElementType<NonNullable<TValue>>,\r\n    ) => ColumnOption\r\n\r\n    /* An optional \"soft\" max for the number range slider. */\r\n    /* This is used for columns with type 'number'. */\r\n    max?: number\r\n  }\r\n}\r\n\r\n/* TODO: Allow both accessorFn and accessorKey */\r\nexport function defineMeta<\r\n  TData,\r\n  /* Only accessorFn - WORKS */\r\n  TAccessor extends AccessorFn<TData>,\r\n  TVal extends ReturnType<TAccessor>,\r\n  /* Only accessorKey - WORKS */\r\n  // TAccessor extends DeepKeys<TData>,\r\n  // TVal extends DeepValue<TData, TAccessor>,\r\n\r\n  /* Both accessorKey and accessorFn - BROKEN */\r\n  /* ISSUE: Won't infer transformOptionFn input type correctly. */\r\n  // TAccessor extends AccessorFn<TData> | DeepKeys<TData>,\r\n  // TVal extends TAccessor extends AccessorFn<TData>\r\n  // ? ReturnType<TAccessor>\r\n  // : TAccessor extends DeepKeys<TData>\r\n  // ? DeepValue<TData, TAccessor>\r\n  // : never,\r\n  TType extends ColumnDataType,\r\n>(\r\n  accessor: TAccessor,\r\n  meta: Omit<ColumnMeta<TData, TVal>, 'type'> & {\r\n    type: TType\r\n  },\r\n): ColumnMeta<TData, TVal> {\r\n  return meta\r\n}\r\n\r\n/*\r\n * Represents a possible value for a column property of type 'option' or 'multiOption'.\r\n */\r\nexport interface ColumnOption {\r\n  /* The label to display for the option. */\r\n  label: string\r\n  /* The internal value of the option. */\r\n  value: string\r\n  /* An optional icon to display next to the label. */\r\n  icon?: React.ReactElement | React.ElementType\r\n}\r\n\r\n/*\r\n * Represents the data type of a column.\r\n */\r\nexport type ColumnDataType =\r\n  /* The column value is a string that should be searchable. */\r\n  | 'text'\r\n  | 'number'\r\n  | 'date'\r\n  /* The column value can be a single value from a list of options. */\r\n  | 'option'\r\n  /* The column value can be zero or more values from a list of options. */\r\n  | 'multiOption'\r\n\r\n/* Operators for text data */\r\nexport type TextFilterOperator = 'contains' | 'does not contain'\r\n\r\n/* Operators for number data */\r\nexport type NumberFilterOperator =\r\n  | 'is'\r\n  | 'is not'\r\n  | 'is less than'\r\n  | 'is greater than or equal to'\r\n  | 'is greater than'\r\n  | 'is less than or equal to'\r\n  | 'is between'\r\n  | 'is not between'\r\n\r\n/* Operators for date data */\r\nexport type DateFilterOperator =\r\n  | 'is'\r\n  | 'is not'\r\n  | 'is before'\r\n  | 'is on or after'\r\n  | 'is after'\r\n  | 'is on or before'\r\n  | 'is between'\r\n  | 'is not between'\r\n\r\n/* Operators for option data */\r\nexport type OptionFilterOperator = 'is' | 'is not' | 'is any of' | 'is none of'\r\n\r\n/* Operators for multi-option data */\r\nexport type MultiOptionFilterOperator =\r\n  | 'include'\r\n  | 'exclude'\r\n  | 'include any of'\r\n  | 'include all of'\r\n  | 'exclude if any of'\r\n  | 'exclude if all'\r\n\r\n/* Maps filter operators to their respective data types */\r\ntype FilterOperators = {\r\n  text: TextFilterOperator\r\n  number: NumberFilterOperator\r\n  date: DateFilterOperator\r\n  option: OptionFilterOperator\r\n  multiOption: MultiOptionFilterOperator\r\n}\r\n\r\n/* Maps filter values to their respective data types */\r\nexport type FilterTypes = {\r\n  text: string\r\n  number: number\r\n  date: Date\r\n  option: string\r\n  multiOption: string[]\r\n}\r\n\r\n/*\r\n *\r\n * FilterValue is a type that represents a filter value for a specific column.\r\n *\r\n * It consists of:\r\n * - Operator: The operator to be used for the filter.\r\n * - Values: An array of values to be used for the filter.\r\n *\r\n */\r\nexport type FilterModel<T extends ColumnDataType, TData> = {\r\n  operator: FilterOperators[T]\r\n  values: Array<FilterTypes[T]>\r\n  columnMeta: Column<TData>['columnDef']['meta']\r\n}\r\n\r\n/*\r\n * FilterDetails is a type that represents the details of all the filter operators for a specific column data type.\r\n */\r\nexport type FilterDetails<T extends ColumnDataType> = {\r\n  [key in FilterOperators[T]]: FilterOperatorDetails<key, T>\r\n}\r\n\r\ntype FilterOperatorDetailsBase<OperatorValue, T extends ColumnDataType> = {\r\n  /* The operator value. Usually the string representation of the operator. */\r\n  value: OperatorValue\r\n  /* The label for the operator, to show in the UI. */\r\n  label: string\r\n  /* How much data the operator applies to. */\r\n  target: 'single' | 'multiple'\r\n  /* The plural form of the operator, if applicable. */\r\n  singularOf?: FilterOperators[T]\r\n  /* The singular form of the operator, if applicable. */\r\n  pluralOf?: FilterOperators[T]\r\n  /* All related operators. Normally, all the operators which share the same target. */\r\n  relativeOf: FilterOperators[T] | Array<FilterOperators[T]>\r\n  /* Whether the operator is negated. */\r\n  isNegated: boolean\r\n  /* If the operator is not negated, this provides the negated equivalent. */\r\n  negation?: FilterOperators[T]\r\n  /* If the operator is negated, this provides the positive equivalent. */\r\n  negationOf?: FilterOperators[T]\r\n}\r\n\r\n/*\r\n *\r\n * FilterOperatorDetails is a type that provides details about a filter operator for a specific column data type.\r\n * It extends FilterOperatorDetailsBase with additional logic and contraints on the defined properties.\r\n *\r\n */\r\nexport type FilterOperatorDetails<\r\n  OperatorValue,\r\n  T extends ColumnDataType,\r\n> = FilterOperatorDetailsBase<OperatorValue, T> &\r\n  (\r\n    | { singularOf?: never; pluralOf?: never }\r\n    | { target: 'single'; singularOf: FilterOperators[T]; pluralOf?: never }\r\n    | { target: 'multiple'; singularOf?: never; pluralOf: FilterOperators[T] }\r\n  ) &\r\n  (\r\n    | { isNegated: false; negation: FilterOperators[T]; negationOf?: never }\r\n    | { isNegated: true; negation?: never; negationOf: FilterOperators[T] }\r\n  )\r\n\r\n/* Details for all the filter operators for option data type */\r\nexport const optionFilterDetails = {\r\n  is: {\r\n    label: 'is',\r\n    value: 'is',\r\n    target: 'single',\r\n    singularOf: 'is not',\r\n    relativeOf: 'is any of',\r\n    isNegated: false,\r\n    negation: 'is not',\r\n  },\r\n  'is not': {\r\n    label: 'is not',\r\n    value: 'is not',\r\n    target: 'single',\r\n    singularOf: 'is',\r\n    relativeOf: 'is none of',\r\n    isNegated: true,\r\n    negationOf: 'is',\r\n  },\r\n  'is any of': {\r\n    label: 'is any of',\r\n    value: 'is any of',\r\n    target: 'multiple',\r\n    pluralOf: 'is',\r\n    relativeOf: 'is',\r\n    isNegated: false,\r\n    negation: 'is none of',\r\n  },\r\n  'is none of': {\r\n    label: 'is none of',\r\n    value: 'is none of',\r\n    target: 'multiple',\r\n    pluralOf: 'is not',\r\n    relativeOf: 'is not',\r\n    isNegated: true,\r\n    negationOf: 'is any of',\r\n  },\r\n} as const satisfies FilterDetails<'option'>\r\n\r\n/* Details for all the filter operators for multi-option data type */\r\nexport const multiOptionFilterDetails = {\r\n  include: {\r\n    label: 'include',\r\n    value: 'include',\r\n    target: 'single',\r\n    singularOf: 'include any of',\r\n    relativeOf: 'exclude',\r\n    isNegated: false,\r\n    negation: 'exclude',\r\n  },\r\n  exclude: {\r\n    label: 'exclude',\r\n    value: 'exclude',\r\n    target: 'single',\r\n    singularOf: 'exclude if any of',\r\n    relativeOf: 'include',\r\n    isNegated: true,\r\n    negationOf: 'include',\r\n  },\r\n  'include any of': {\r\n    label: 'include any of',\r\n    value: 'include any of',\r\n    target: 'multiple',\r\n    pluralOf: 'include',\r\n    relativeOf: ['exclude if all', 'include all of', 'exclude if any of'],\r\n    isNegated: false,\r\n    negation: 'exclude if all',\r\n  },\r\n  'exclude if all': {\r\n    label: 'exclude if all',\r\n    value: 'exclude if all',\r\n    target: 'multiple',\r\n    pluralOf: 'exclude',\r\n    relativeOf: ['include any of', 'include all of', 'exclude if any of'],\r\n    isNegated: true,\r\n    negationOf: 'include any of',\r\n  },\r\n  'include all of': {\r\n    label: 'include all of',\r\n    value: 'include all of',\r\n    target: 'multiple',\r\n    pluralOf: 'include',\r\n    relativeOf: ['include any of', 'exclude if all', 'exclude if any of'],\r\n    isNegated: false,\r\n    negation: 'exclude if any of',\r\n  },\r\n  'exclude if any of': {\r\n    label: 'exclude if any of',\r\n    value: 'exclude if any of',\r\n    target: 'multiple',\r\n    pluralOf: 'exclude',\r\n    relativeOf: ['include any of', 'exclude if all', 'include all of'],\r\n    isNegated: true,\r\n    negationOf: 'include all of',\r\n  },\r\n} as const satisfies FilterDetails<'multiOption'>\r\n\r\n/* Details for all the filter operators for date data type */\r\nexport const dateFilterDetails = {\r\n  is: {\r\n    label: 'is',\r\n    value: 'is',\r\n    target: 'single',\r\n    singularOf: 'is between',\r\n    relativeOf: 'is after',\r\n    isNegated: false,\r\n    negation: 'is before',\r\n  },\r\n  'is not': {\r\n    label: 'is not',\r\n    value: 'is not',\r\n    target: 'single',\r\n    singularOf: 'is not between',\r\n    relativeOf: [\r\n      'is',\r\n      'is before',\r\n      'is on or after',\r\n      'is after',\r\n      'is on or before',\r\n    ],\r\n    isNegated: true,\r\n    negationOf: 'is',\r\n  },\r\n  'is before': {\r\n    label: 'is before',\r\n    value: 'is before',\r\n    target: 'single',\r\n    singularOf: 'is between',\r\n    relativeOf: [\r\n      'is',\r\n      'is not',\r\n      'is on or after',\r\n      'is after',\r\n      'is on or before',\r\n    ],\r\n    isNegated: false,\r\n    negation: 'is on or after',\r\n  },\r\n  'is on or after': {\r\n    label: 'is on or after',\r\n    value: 'is on or after',\r\n    target: 'single',\r\n    singularOf: 'is between',\r\n    relativeOf: ['is', 'is not', 'is before', 'is after', 'is on or before'],\r\n    isNegated: false,\r\n    negation: 'is before',\r\n  },\r\n  'is after': {\r\n    label: 'is after',\r\n    value: 'is after',\r\n    target: 'single',\r\n    singularOf: 'is between',\r\n    relativeOf: [\r\n      'is',\r\n      'is not',\r\n      'is before',\r\n      'is on or after',\r\n      'is on or before',\r\n    ],\r\n    isNegated: false,\r\n    negation: 'is on or before',\r\n  },\r\n  'is on or before': {\r\n    label: 'is on or before',\r\n    value: 'is on or before',\r\n    target: 'single',\r\n    singularOf: 'is between',\r\n    relativeOf: ['is', 'is not', 'is after', 'is on or after', 'is before'],\r\n    isNegated: false,\r\n    negation: 'is after',\r\n  },\r\n  'is between': {\r\n    label: 'is between',\r\n    value: 'is between',\r\n    target: 'multiple',\r\n    pluralOf: 'is',\r\n    relativeOf: 'is not between',\r\n    isNegated: false,\r\n    negation: 'is not between',\r\n  },\r\n  'is not between': {\r\n    label: 'is not between',\r\n    value: 'is not between',\r\n    target: 'multiple',\r\n    pluralOf: 'is not',\r\n    relativeOf: 'is between',\r\n    isNegated: true,\r\n    negationOf: 'is between',\r\n  },\r\n} as const satisfies FilterDetails<'date'>\r\n\r\n/* Details for all the filter operators for text data type */\r\nexport const textFilterDetails = {\r\n  contains: {\r\n    label: 'contains',\r\n    value: 'contains',\r\n    target: 'single',\r\n    relativeOf: 'does not contain',\r\n    isNegated: false,\r\n    negation: 'does not contain',\r\n  },\r\n  'does not contain': {\r\n    label: 'does not contain',\r\n    value: 'does not contain',\r\n    target: 'single',\r\n    relativeOf: 'contains',\r\n    isNegated: true,\r\n    negationOf: 'contains',\r\n  },\r\n} as const satisfies FilterDetails<'text'>\r\n\r\n/* Details for all the filter operators for number data type */\r\nexport const numberFilterDetails = {\r\n  is: {\r\n    label: 'is',\r\n    value: 'is',\r\n    target: 'single',\r\n    relativeOf: [\r\n      'is not',\r\n      'is greater than',\r\n      'is less than or equal to',\r\n      'is less than',\r\n      'is greater than or equal to',\r\n    ],\r\n    isNegated: false,\r\n    negation: 'is not',\r\n  },\r\n  'is not': {\r\n    label: 'is not',\r\n    value: 'is not',\r\n    target: 'single',\r\n    relativeOf: [\r\n      'is',\r\n      'is greater than',\r\n      'is less than or equal to',\r\n      'is less than',\r\n      'is greater than or equal to',\r\n    ],\r\n    isNegated: true,\r\n    negationOf: 'is',\r\n  },\r\n  'is greater than': {\r\n    label: '>',\r\n    value: 'is greater than',\r\n    target: 'single',\r\n    relativeOf: [\r\n      'is',\r\n      'is not',\r\n      'is less than or equal to',\r\n      'is less than',\r\n      'is greater than or equal to',\r\n    ],\r\n    isNegated: false,\r\n    negation: 'is less than or equal to',\r\n  },\r\n  'is greater than or equal to': {\r\n    label: '>=',\r\n    value: 'is greater than or equal to',\r\n    target: 'single',\r\n    relativeOf: [\r\n      'is',\r\n      'is not',\r\n      'is greater than',\r\n      'is less than or equal to',\r\n      'is less than',\r\n    ],\r\n    isNegated: false,\r\n    negation: 'is less than or equal to',\r\n  },\r\n  'is less than': {\r\n    label: '<',\r\n    value: 'is less than',\r\n    target: 'single',\r\n    relativeOf: [\r\n      'is',\r\n      'is not',\r\n      'is greater than',\r\n      'is less than or equal to',\r\n      'is greater than or equal to',\r\n    ],\r\n    isNegated: false,\r\n    negation: 'is greater than',\r\n  },\r\n  'is less than or equal to': {\r\n    label: '<=',\r\n    value: 'is less than or equal to',\r\n    target: 'single',\r\n    relativeOf: [\r\n      'is',\r\n      'is not',\r\n      'is greater than',\r\n      'is less than',\r\n      'is greater than or equal to',\r\n    ],\r\n    isNegated: false,\r\n    negation: 'is greater than or equal to',\r\n  },\r\n  'is between': {\r\n    label: 'is between',\r\n    value: 'is between',\r\n    target: 'multiple',\r\n    relativeOf: 'is not between',\r\n    isNegated: false,\r\n    negation: 'is not between',\r\n  },\r\n  'is not between': {\r\n    label: 'is not between',\r\n    value: 'is not between',\r\n    target: 'multiple',\r\n    relativeOf: 'is between',\r\n    isNegated: true,\r\n    negationOf: 'is between',\r\n  },\r\n} as const satisfies FilterDetails<'number'>\r\n\r\n/* Maps column data types to their respective filter operator details */\r\ntype FilterTypeOperatorDetails = {\r\n  [key in ColumnDataType]: FilterDetails<key>\r\n}\r\n\r\nexport const filterTypeOperatorDetails: FilterTypeOperatorDetails = {\r\n  text: textFilterDetails,\r\n  number: numberFilterDetails,\r\n  date: dateFilterDetails,\r\n  option: optionFilterDetails,\r\n  multiOption: multiOptionFilterDetails,\r\n}\r\n\r\n/*\r\n *\r\n * Determines the new operator for a filter based on the current operator, old and new filter values.\r\n *\r\n * This handles cases where the filter values have transitioned from a single value to multiple values (or vice versa),\r\n * and the current operator needs to be transitioned to its plural form (or singular form).\r\n *\r\n * For example, if the current operator is 'is', and the new filter values have a length of 2, the\r\n * new operator would be 'is any of'.\r\n *\r\n */\r\nexport function determineNewOperator<T extends ColumnDataType>(\r\n  type: T,\r\n  oldVals: Array<FilterTypes[T]>,\r\n  nextVals: Array<FilterTypes[T]>,\r\n  currentOperator: FilterOperators[T],\r\n): FilterOperators[T] {\r\n  const a =\r\n    Array.isArray(oldVals) && Array.isArray(oldVals[0])\r\n      ? oldVals[0].length\r\n      : oldVals.length\r\n  const b =\r\n    Array.isArray(nextVals) && Array.isArray(nextVals[0])\r\n      ? nextVals[0].length\r\n      : nextVals.length\r\n\r\n  // If filter size has not transitioned from single to multiple (or vice versa)\r\n  // or is unchanged, return the current operator.\r\n  if (a === b || (a >= 2 && b >= 2) || (a <= 1 && b <= 1))\r\n    return currentOperator\r\n\r\n  const opDetails = filterTypeOperatorDetails[type][currentOperator]\r\n\r\n  // Handle transition from single to multiple filter values.\r\n  if (a < b && b >= 2) return opDetails.singularOf ?? currentOperator\r\n  // Handle transition from multiple to single filter values.\r\n  if (a > b && b <= 1) return opDetails.pluralOf ?? currentOperator\r\n  return currentOperator\r\n}\r\n\r\n/**********************************************************************************************************\r\n ***** Filter Functions ******\r\n **********************************************************************************************************\r\n * These are functions that filter data based on the current filter values, column data type, and operator.\r\n * There exists a separate filter function for each column data type.\r\n *\r\n * Two variants of the filter functions are provided - as an example, we will take the optionFilterFn:\r\n * 1. optionFilterFn: takes in a row, columnId, and filterValue.\r\n * 2. __optionFilterFn: takes in an inputData and filterValue.\r\n *\r\n * __optionFilterFn is a private function that is used by filterFn to perform the actual filtering.\r\n * *********************************************************************************************************/\r\n\r\n/*\r\n * Returns a filter function for a given column data type.\r\n * This function is used to determine the appropriate filter function to use based on the column data type.\r\n */\r\nexport function filterFn(dataType: ColumnDataType) {\r\n  switch (dataType) {\r\n    case 'option':\r\n      return optionFilterFn\r\n    case 'multiOption':\r\n      return multiOptionFilterFn\r\n    case 'date':\r\n      return dateFilterFn\r\n    case 'text':\r\n      return textFilterFn\r\n    case 'number':\r\n      return numberFilterFn\r\n    default:\r\n      throw new Error('Invalid column data type')\r\n  }\r\n}\r\n\r\nexport function optionFilterFn<TData>(\r\n  row: Row<TData>,\r\n  columnId: string,\r\n  filterValue: FilterModel<'option', TData>,\r\n) {\r\n  const value = row.getValue(columnId)\r\n\r\n  if (!value) return false\r\n\r\n  const columnMeta = filterValue.columnMeta!\r\n\r\n  if (typeof value === 'string') {\r\n    return __optionFilterFn(value, filterValue)\r\n  }\r\n\r\n  if (isColumnOption(value)) {\r\n    return __optionFilterFn(value.value, filterValue)\r\n  }\r\n\r\n  const sanitizedValue = columnMeta.transformOptionFn!(value as never)\r\n  return __optionFilterFn(sanitizedValue.value, filterValue)\r\n}\r\n\r\nexport function __optionFilterFn<TData>(\r\n  inputData: string,\r\n  filterValue: FilterModel<'option', TData>,\r\n) {\r\n  if (!inputData) return false\r\n  if (filterValue.values.length === 0) return true\r\n\r\n  const value = inputData.toString().toLowerCase()\r\n\r\n  const found = !!filterValue.values.find((v) => v.toLowerCase() === value)\r\n\r\n  switch (filterValue.operator) {\r\n    case 'is':\r\n    case 'is any of':\r\n      return found\r\n    case 'is not':\r\n    case 'is none of':\r\n      return !found\r\n  }\r\n}\r\n\r\nexport function isColumnOption(value: unknown): value is ColumnOption {\r\n  return (\r\n    typeof value === 'object' &&\r\n    value !== null &&\r\n    'value' in value &&\r\n    'label' in value\r\n  )\r\n}\r\n\r\nexport function isColumnOptionArray(value: unknown): value is ColumnOption[] {\r\n  return Array.isArray(value) && value.every(isColumnOption)\r\n}\r\n\r\nfunction isStringArray(value: unknown): value is string[] {\r\n  return Array.isArray(value) && value.every((v) => typeof v === 'string')\r\n}\r\n\r\nexport function multiOptionFilterFn<TData>(\r\n  row: Row<TData>,\r\n  columnId: string,\r\n  filterValue: FilterModel<'multiOption', TData>,\r\n) {\r\n  const value = row.getValue(columnId)\r\n\r\n  if (!value) return false\r\n\r\n  const columnMeta = filterValue.columnMeta!\r\n\r\n  if (isStringArray(value)) {\r\n    return __multiOptionFilterFn(value, filterValue)\r\n  }\r\n\r\n  if (isColumnOptionArray(value)) {\r\n    return __multiOptionFilterFn(\r\n      value.map((v) => v.value),\r\n      filterValue,\r\n    )\r\n  }\r\n\r\n  const sanitizedValue = (value as never[]).map((v) =>\r\n    columnMeta.transformOptionFn!(v),\r\n  )\r\n\r\n  return __multiOptionFilterFn(\r\n    sanitizedValue.map((v) => v.value),\r\n    filterValue,\r\n  )\r\n}\r\n\r\nexport function __multiOptionFilterFn<TData>(\r\n  inputData: string[],\r\n  filterValue: FilterModel<'multiOption', TData>,\r\n) {\r\n  if (!inputData) return false\r\n\r\n  if (\r\n    filterValue.values.length === 0 ||\r\n    !filterValue.values[0] ||\r\n    filterValue.values[0].length === 0\r\n  )\r\n    return true\r\n\r\n  const values = uniq(inputData)\r\n  const filterValues = uniq(filterValue.values[0])\r\n\r\n  switch (filterValue.operator) {\r\n    case 'include':\r\n    case 'include any of':\r\n      return intersection(values, filterValues).length > 0\r\n    case 'exclude':\r\n      return intersection(values, filterValues).length === 0\r\n    case 'exclude if any of':\r\n      return !(intersection(values, filterValues).length > 0)\r\n    case 'include all of':\r\n      return intersection(values, filterValues).length === filterValues.length\r\n    case 'exclude if all':\r\n      return !(\r\n        intersection(values, filterValues).length === filterValues.length\r\n      )\r\n  }\r\n}\r\n\r\nexport function dateFilterFn<TData>(\r\n  row: Row<TData>,\r\n  columnId: string,\r\n  filterValue: FilterModel<'date', TData>,\r\n) {\r\n  const valueStr = row.getValue<Date>(columnId)\r\n\r\n  return __dateFilterFn(valueStr, filterValue)\r\n}\r\n\r\nexport function __dateFilterFn<TData>(\r\n  inputData: Date,\r\n  filterValue: FilterModel<'date', TData>,\r\n) {\r\n  if (!filterValue || filterValue.values.length === 0) return true\r\n\r\n  if (\r\n    dateFilterDetails[filterValue.operator].target === 'single' &&\r\n    filterValue.values.length > 1\r\n  )\r\n    throw new Error('Singular operators require at most one filter value')\r\n\r\n  if (\r\n    filterValue.operator in ['is between', 'is not between'] &&\r\n    filterValue.values.length !== 2\r\n  )\r\n    throw new Error('Plural operators require two filter values')\r\n\r\n  const filterVals = filterValue.values\r\n  const d1 = filterVals[0]\r\n  const d2 = filterVals[1]\r\n\r\n  const value = inputData\r\n\r\n  switch (filterValue.operator) {\r\n    case 'is':\r\n      return isSameDay(value, d1)\r\n    case 'is not':\r\n      return !isSameDay(value, d1)\r\n    case 'is before':\r\n      return isBefore(value, startOfDay(d1))\r\n    case 'is on or after':\r\n      return isSameDay(value, d1) || isAfter(value, startOfDay(d1))\r\n    case 'is after':\r\n      return isAfter(value, startOfDay(d1))\r\n    case 'is on or before':\r\n      return isSameDay(value, d1) || isBefore(value, startOfDay(d1))\r\n    case 'is between':\r\n      return isWithinInterval(value, {\r\n        start: startOfDay(d1),\r\n        end: endOfDay(d2),\r\n      })\r\n    case 'is not between':\r\n      return !isWithinInterval(value, {\r\n        start: startOfDay(filterValue.values[0]),\r\n        end: endOfDay(filterValue.values[1]),\r\n      })\r\n  }\r\n}\r\n\r\nexport function textFilterFn<TData>(\r\n  row: Row<TData>,\r\n  columnId: string,\r\n  filterValue: FilterModel<'text', TData>,\r\n) {\r\n  const value = row.getValue<string>(columnId) ?? ''\r\n\r\n  return __textFilterFn(value, filterValue)\r\n}\r\n\r\nexport function __textFilterFn<TData>(\r\n  inputData: string,\r\n  filterValue: FilterModel<'text', TData>,\r\n) {\r\n  if (!filterValue || filterValue.values.length === 0) return true\r\n\r\n  const value = inputData.toLowerCase().trim()\r\n  const filterStr = filterValue.values[0].toLowerCase().trim()\r\n\r\n  if (filterStr === '') return true\r\n\r\n  const found = value.includes(filterStr)\r\n\r\n  switch (filterValue.operator) {\r\n    case 'contains':\r\n      return found\r\n    case 'does not contain':\r\n      return !found\r\n  }\r\n}\r\n\r\nexport function numberFilterFn<TData>(\r\n  row: Row<TData>,\r\n  columnId: string,\r\n  filterValue: FilterModel<'number', TData>,\r\n) {\r\n  const value = row.getValue<number>(columnId)\r\n\r\n  return __numberFilterFn(value, filterValue)\r\n}\r\n\r\nexport function __numberFilterFn<TData>(\r\n  inputData: number,\r\n  filterValue: FilterModel<'number', TData>,\r\n) {\r\n  if (!filterValue || !filterValue.values || filterValue.values.length === 0) {\r\n    return true\r\n  }\r\n\r\n  const value = inputData\r\n  const filterVal = filterValue.values[0]\r\n\r\n  switch (filterValue.operator) {\r\n    case 'is':\r\n      return value === filterVal\r\n    case 'is not':\r\n      return value !== filterVal\r\n    case 'is greater than':\r\n      return value > filterVal\r\n    case 'is greater than or equal to':\r\n      return value >= filterVal\r\n    case 'is less than':\r\n      return value < filterVal\r\n    case 'is less than or equal to':\r\n      return value <= filterVal\r\n    case 'is between': {\r\n      const lowerBound = filterValue.values[0]\r\n      const upperBound = filterValue.values[1]\r\n      return value >= lowerBound && value <= upperBound\r\n    }\r\n    case 'is not between': {\r\n      const lowerBound = filterValue.values[0]\r\n      const upperBound = filterValue.values[1]\r\n      return value < lowerBound || value > upperBound\r\n    }\r\n    default:\r\n      return true\r\n  }\r\n}\r\n\r\nexport function createNumberRange(values: number[] | undefined) {\r\n  let a = 0\r\n  let b = 0\r\n\r\n  if (!values || values.length === 0) return [a, b]\r\n  if (values.length === 1) {\r\n    a = values[0]\r\n  } else {\r\n    a = values[0]\r\n    b = values[1]\r\n  }\r\n\r\n  const [min, max] = a < b ? [a, b] : [b, a]\r\n\r\n  return [min, max]\r\n}\r\n\r\n/*** Table helpers ***/\r\n\r\nexport function getColumn<TData>(table: Table<TData>, id: string) {\r\n  const column = table.getColumn(id)\r\n\r\n  if (!column) {\r\n    throw new Error(`Column with id ${id} not found`)\r\n  }\r\n\r\n  return column\r\n}\r\n\r\nexport function getColumnMeta<TData>(table: Table<TData>, id: string) {\r\n  const column = getColumn(table, id)\r\n\r\n  if (!column.columnDef.meta) {\r\n    throw new Error(`Column meta not found for column ${id}`)\r\n  }\r\n\r\n  return column.columnDef.meta\r\n}\r\n\r\n/*** Table Filter Helpers ***/\r\n\r\nexport function isFilterableColumn<TData>(column: Column<TData>) {\r\n  // 'auto' filterFn doesn't count!\r\n  const hasFilterFn =\r\n    column.columnDef.filterFn && column.columnDef.filterFn !== 'auto'\r\n\r\n  if (\r\n    column.getCanFilter() &&\r\n    column.accessorFn &&\r\n    hasFilterFn &&\r\n    column.columnDef.meta\r\n  )\r\n    return true\r\n\r\n  if (!column.accessorFn || !column.columnDef.meta) {\r\n    // 1) Column has no accessor function\r\n    //    We assume this is a display column and thus has no filterable data\r\n    // 2) Column has no meta\r\n    //    We assume this column is not intended to be filtered using this component\r\n    return false\r\n  }\r\n\r\n  if (!column.accessorFn) {\r\n    warn(`Column \"${column.id}\" ignored - no accessor function`)\r\n  }\r\n\r\n  if (!column.getCanFilter()) {\r\n    warn(`Column \"${column.id}\" ignored - not filterable`)\r\n  }\r\n\r\n  if (!hasFilterFn) {\r\n    warn(\r\n      `Column \"${column.id}\" ignored - no filter function. use the provided filterFn() helper function`,\r\n    )\r\n  }\r\n\r\n  return false\r\n}\r\n\r\nfunction warn(...messages: string[]) {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    console.warn('[] [filters]', ...messages)\r\n  }\r\n}\r\n",
      "type": "registry:lib"
    }
  ]
}
